---
title: "ICE development - Study 3 - data analysis"
author: "Michalina Marczak"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r, include=FALSE}
# For starters
#Load the required libraries: tidyverse, dplyr, psych, car, rptR, as well as custom functions.

#set the global options
options(max.print=999999)  #allows printing out large outputs
options(scipen = 999)  #disables scientific notation (uses decimal instead)   
set.seed(9999) # set seed for replicability

####### load the packages needed for data analysis 
library(tidyverse)
library(dplyr)
library(psych)
library(car)
library(rptR) #devtools::install_github("mastoffel/rptR", build_vignettes = TRUE)

# CUSTOM FUNCTIONS
#the first two are from Paul van der Laken (https://paulvanderlaken.com/2020/07/28/publication-ready-correlation-matrix-significance-r/#correlation_matrix), and the last one is from Mehmet Mehmetoglu.

#' correlation_matrix
#' Creates a publication-ready / formatted correlation matrix, using `Hmisc::rcorr` in the backend.
#'
#' @param df dataframe; containing numeric and/or logical columns to calculate correlations for
#' @param type character; specifies the type of correlations to compute; gets passed to `Hmisc::rcorr`; options are `"pearson"` or `"spearman"`; defaults to `"pearson"`
#' @param digits integer/double; number of decimals to show in the correlation matrix; gets passed to `formatC`; defaults to `3`
#' @param decimal.mark character; which decimal.mark to use; gets passed to `formatC`; defaults to `.`
#' @param use character; which part of the correlation matrix to display; options are `"all"`, `"upper"`, `"lower"`; defaults to `"all"`
#' @param show_significance boolean; whether to add `*` to represent the significance levels for the correlations; defaults to `TRUE`
#' @param replace_diagonal boolean; whether to replace the correlations on the diagonal; defaults to `FALSE`
#' @param replacement character; what to replace the diagonal and/or upper/lower triangles with; defaults to `""` (empty string)
#'
#' @return a correlation matrix
#' @export
#'
#' @examples
#' `correlation_matrix(iris)`
#' `correlation_matrix(mtcars)`
correlation_matrix <- function(df, 
                               type = "pearson",
                               digits = 3, 
                               decimal.mark = ".",
                               use = "all", 
                               show_significance = TRUE, 
                               replace_diagonal = FALSE, 
                               replacement = ""){
  
  # check arguments
  stopifnot({
    is.numeric(digits)
    digits >= 0
    use %in% c("all", "upper", "lower")
    is.logical(replace_diagonal)
    is.logical(show_significance)
    is.character(replacement)
  })
  # we need the Hmisc package for this
  require(Hmisc)
  
  # retain only numeric and boolean columns
  isNumericOrBoolean = vapply(df, function(x) is.numeric(x) | is.logical(x), logical(1))
  if (sum(!isNumericOrBoolean) > 0) {
    cat('Dropping non-numeric/-boolean column(s):', paste(names(isNumericOrBoolean)[!isNumericOrBoolean], collapse = ', '), '\n\n')
  }
  df = df[isNumericOrBoolean]
  
  # transform input data frame to matrix
  x <- as.matrix(df)
  
  # run correlation analysis using Hmisc package
  correlation_matrix <- Hmisc::rcorr(x, type = type)
  R <- correlation_matrix$r # Matrix of correlation coeficients
  p <- correlation_matrix$P # Matrix of p-value 
  
  # transform correlations to specific character format
  Rformatted = formatC(R, format = 'f', digits = digits, decimal.mark = decimal.mark)
  
  # if there are any negative numbers, we want to put a space before the positives to align all
  if (sum(!is.na(R) & R < 0) > 0) {
    Rformatted = ifelse(!is.na(R) & R > 0, paste0(" ", Rformatted), Rformatted)
  }

  # add significance levels if desired
  if (show_significance) {
    # define notions for significance levels; spacing is important.
    stars <- ifelse(is.na(p), "", ifelse(p < .001, "***", ifelse(p < .01, "**", ifelse(p < .05, "*", ""))))
    Rformatted = paste0(Rformatted, stars)
  }
  
  # make all character strings equally long
  max_length = max(nchar(Rformatted))
  Rformatted = vapply(Rformatted, function(x) {
    current_length = nchar(x)
    difference = max_length - current_length
    return(paste0(x, paste(rep(" ", difference), collapse = ''), sep = ''))
  }, FUN.VALUE = character(1))
  
  # build a new matrix that includes the formatted correlations and their significance stars
  Rnew <- matrix(Rformatted, ncol = ncol(x))
  rownames(Rnew) <- colnames(Rnew) <- colnames(x)
  
  # replace undesired values
  if (use == 'upper') {
    Rnew[lower.tri(Rnew, diag = replace_diagonal)] <- replacement
  } else if (use == 'lower') {
    Rnew[upper.tri(Rnew, diag = replace_diagonal)] <- replacement
  } else if (replace_diagonal) {
    diag(Rnew) <- replacement
  }
  
  return(Rnew)
}


#' save_correlation_matrix
#' Creates and save to file a fully formatted correlation matrix, using `correlation_matrix` and `Hmisc::rcorr` in the backend
#' @param df dataframe; passed to `correlation_matrix`
#' @param filename either a character string naming a file or a connection open for writing. "" indicates output to the console; passed to `write.csv`
#' @param ... any other arguments passed to `correlation_matrix`
#'
#' @return NULL
#'
#' @examples
#' `save_correlation_matrix(df = iris, filename = 'iris-correlation-matrix.csv')`
#' `save_correlation_matrix(df = mtcars, filename = 'mtcars-correlation-matrix.csv', digits = 3, use = 'lower')`
save_correlation_matrix = function(df, filename, ...) {
  return(write.csv2(correlation_matrix(df, ...), file = filename))
}
```


```{r, include=F}
#Load the dataset
load("./S3/02/output/dataset.RData")
```


```{r, include=F}
# Climate emotions data
#Subset the data frame with data on climate emotions.
ICE_32 <- dplyr::select(qdata, starts_with("ICE-32"))
```

```{r, include=FALSE}
ICE_32 <- as.data.frame(ICE_32)

#change the variables type from character to numeric (keeping them in the data frame format)
ICE_32 <- as.data.frame(lapply(ICE_32, as.numeric))
```

## Inspecting the climate emotions data

```{r, include=F}
#Explore & inspect the ICE data.
#is there any missing data?
sum(colSums(is.na(ICE_32)))

#a categorical representation of the ICE data to check for inconsistent values
#lapply(ICE_32, table) # I won't print it here because it takes a lot of space
```

```{r, include=F}
# For the descriptives, the response format should be 1-5 not 0-4, hence we add 1 to each value in the data frame
ICE_32 <- ICE_32 + 1
```

```{r, include=F}
# Overview of the descriptives 
psych::describe(ICE_32)
```

```{r, include=F}
#### Add columns with mean scores across climate emotions
ICE_32 <- ICE_32 %>% 
  mutate(climate.anger = rowSums(.[1:4]/4), 
         climate.contempt = rowSums(.[5:8]/4), 
         climate.enthusiasm = rowSums(.[9:12]/4), 
         climate.powerlessness = rowSums(.[13:16]/4), 
         climate.guilt = rowSums(.[17:20])/4,
         climate.isolation = rowSums(.[21:24]/4),
         climate.anxiety = rowSums(.[25:28])/4,
         climate.sorrow = rowSums(.[29:32])/4)

#Also: a df with scales only to make it easier for the analysis
s_ICE_32 <- ICE_32[33:40]
```

```{r, include=F}
#Save the output for the paper
#S3_descriptives_for_printout <- psych::describe(s_ICE_32)
#write.table(S3_descriptives_for_printout, file = "s3_desc_ICE.csv", sep = ";")
```

### Descriptives 
```{r, include=T, echo = F}
knitr::kable(psych::describe(s_ICE_32), "simple")
```

### Distributions {.tabset}

#### Formal test
```{r, include=T, echo = F}
## formal test - shapiro-wilk
lapply(s_ICE_32, shapiro.test)
```

#### Visual inspection
```{r, include=T, echo = F}
theme_set(
  theme_minimal() +
    theme(legend.position = "top")
)

s_ICE_32.gathered <- s_ICE_32 %>%
  as_tibble() %>%
  select_if(is.numeric) %>%
  gather(key = "variable", value = "value")

ggplot(s_ICE_32.gathered, aes(value)) +
  geom_density(fill = "lightgrey") +
  facet_wrap(~variable)
```

### Internal consistencies

We inspect the internal consistencies of the ICE scales using Cronbach's alpha coefficient
```{r, include=F}
anger <- dplyr::select(ICE_32, c(1:4))
contempt <- dplyr::select(ICE_32, c(5:8))
enthusiasm <- dplyr::select(ICE_32, c(9:12))
powerlessness <- dplyr::select(ICE_32, c(13:16))
guilt <- dplyr::select(ICE_32, c(17:20))
isolation <- dplyr::select(ICE_32, c(21:24))
anxiety <- dplyr::select(ICE_32, c(25:28))
sorrow <- dplyr::select(ICE_32, c(29:32))

ICE_reliabilities_list <- list(anger, contempt, 
                               enthusiasm, powerlessness, guilt,
                               isolation, anxiety, sorrow)

compute.alpha.each.scale <- lapply(ICE_reliabilities_list, psych::alpha, check.keys=TRUE)
s_reliabilities <- sapply(compute.alpha.each.scale, "[[", 1)[1:2,]
colnames(s_reliabilities) <- c("anger", "contempt", 
                               "enthusiasm", "powerlessness", "guilt",
                               "isolation", "anxiety", "sorrow")
```

```{r, include=T, echo = F}
knitr::kable(s_reliabilities, "simple")
```

```{r, include=F, echo = F}
#save the output to copy it to the paper easily
#write.table(s_reliabilities, file = "ICE_rel.csv", sep = ";")
```

## Inspecting the Mental Health Continuum data

```{r, include=F}
#Create a data frame with the MHC data
MHC <- dplyr::select(qdata, starts_with("MHC"))
```

```{r, include=F}
MHC <- as.data.frame(MHC)

#change the variables type from character to numeric (keeping them in the data frame format)
MHC <- as.data.frame(lapply(MHC, as.numeric))
```


```{r, include=F}
#Explore and inspect the MHC data 
#is there any missing data?
#sum(colSums(is.na(MHC)))

#a categorical representation of the data to check for inconsistent values
#lapply(MHC, table) 
```

```{r, include=F}
# For the descriptives, the response format should be 1-6 not 0-5, hence I add 1 to each value in the data frame
MHC <- MHC + 1
```

```{r, include=F}
# Overview of the descriptives of the MHC data
psych::describe(MHC)
```

```{r, include=F}
# Add columns with the mean composite scores on emotional wellbeing, social wellbeing and psychological wellbeing
MHC <- MHC %>% 
  mutate(emo_wb = rowSums(.[1:3]/3), 
         soc_wb = rowSums(.[4:8]/5), 
         psy_wb = rowSums(.[9:14]/6))


#Also: a dataframe with MHC composite scores only to make the analysis easier
s_MHC <- MHC[15:17]
```

```{r, include=F}
# Save in a table to make it easier to copy the values to the paper
#MHC_descr_for_printout <- psych::describe(s_MHC)
#write.table(MHC_descr_for_printout, file = "s3_descr_MHC.csv", sep = ";")
```

### Descriptives
```{r, include=T, echo = F}
# Overview of the descriptives of the MHC data
knitr::kable(psych::describe(s_MHC), "simple")
```

### Distributions {.tabset}

#### Formal test
```{r, include=T, echo = F}
lapply(s_MHC, shapiro.test)
```

#### Visual inspection
```{r, include=T, echo = F}
s_MHC.gathered <- s_MHC %>%
  as_tibble() %>%
  select_if(is.numeric) %>%
  gather(key = "variable", value = "value")

ggplot(s_MHC.gathered, aes(value)) +
  geom_density(fill = "lightgrey") +
  facet_wrap(~variable)
```

### Internal consistencies

We inspect the internal consistencies of the MHC scales using Cronbach's alpha coefficient
```{r, include=F}
emo_wb <- dplyr::select(MHC, c(1:3))
soc_wb <- dplyr::select(MHC, c(4:8))
psy_wb <- dplyr::select(MHC, c(9:14))

MHC_reliabilities_list <- list(emo_wb, soc_wb, psy_wb)

compute.alpha.each.scale <- lapply(MHC_reliabilities_list, psych::alpha, check.keys=TRUE)
s_reliabilities <- sapply(compute.alpha.each.scale, "[[", 1)[1:2,]
colnames(s_reliabilities) <- c("emo_wb", "soc_wb", "psy_wb")
```

```{r, include=T, echo = F}
knitr::kable(s_reliabilities, "simple")
```

```{r, include=F}
# save in a table to make it easier to copy the values to the paper
#write.table(s_reliabilities, file = "MHC_rel.csv", sep = ";")
```

## Repeatability of climate emotions over time

```{r, include=F}
# first, create a vector of variable names that are relevant for the icc analysis
load("./S3/02/output/dataset.RData")
S3_icc_data <- dplyr::select(qdata, starts_with(c("token", "ts", "ICE-32")))
S3_icc_data <- as.data.frame(S3_icc_data)
names(S3_icc_data) <- sub(".*\\.", "", names(S3_icc_data)) #retain only the core names of the variables from the ICE scale
names.vector <- names(S3_icc_data)

# now, subset and recode to numbers the character data from S1
load("./S1/02/output/dataset.RData")
S1_icc_data <- dplyr::select(qdata, starts_with(c("token", "ts", "ICE")))
S1_icc_data <- as.data.frame(S1_icc_data)
names(S1_icc_data) <- sub(".*\\.", "", names(S1_icc_data)) #retain only the core names of the variables from the ICE scale
S1_icc_data <- S1_icc_data[names.vector]

#there's some mysterious whitespace that isn't a space in character string that messes up with the recoding
#Let's identify it
utf8::utf8_print(S1_icc_data$ANG14, utf8 = FALSE)

#and I get rid of it
S1_icc_data <- as.data.frame(
  apply(S1_icc_data, 2, function(x) gsub("\u00a0", "", x)))

#Now, let's recode the character strings in the ICE responses into numbers from 1 to 5

S1_icc_data <- lapply(S1_icc_data, FUN = function(x) car::recode(x, "'Zdecydowanie tak' = 5; 'Raczej tak' = 4; 
                                              'Ani tak, ani nie' = 3; 'Raczej nie' = 2;
                                              'Zdecydowanie nie'= 1"))


#change the variables type from character to numeric (keeping them in the data frame format)
S3_icc_data[,c(3:34)] <- as.data.frame(lapply(S3_icc_data[,c(3:34)], as.numeric))


### create mean scores for each of the 8 scales for t1 and t2
S3_icc_means <- S3_icc_data %>% 
  mutate(t2_Mclimate.anger = rowMeans(.[3:6]), 
         t2_Mclimate.contempt = rowMeans(.[7:10]), 
         t2_Mclimate.enthusiasm = rowMeans(.[11:14]), 
         t2_Mclimate.powerlessness = rowMeans(.[15:18]), 
         t2_Mclimate.guilt = rowMeans(.[19:22]),
         t2_Mclimate.isolation = rowMeans(.[23:26]),
         t2_Mclimate.anxiety = rowMeans(.[27:30]),
         t2_Mclimate.sorrow = rowMeans(.[31:34]))

S1_icc_data <- as.data.frame(S1_icc_data)
S1_icc_means <- S1_icc_data %>% 
  mutate(t1_Mclimate.anger = rowMeans(.[3:6]), 
         t1_Mclimate.contempt = rowMeans(.[7:10]), 
         t1_Mclimate.enthusiasm = rowMeans(.[11:14]), 
         t1_Mclimate.powerlessness = rowMeans(.[15:18]), 
         t1_Mclimate.guilt = rowMeans(.[19:22]),
         t1_Mclimate.isolation = rowMeans(.[23:26]),
         t1_Mclimate.anxiety = rowMeans(.[27:30]),
         t1_Mclimate.sorrow = rowMeans(.[31:34]))
```

```{r, include=F}
#merge dataframes matching by respondents tokens (unique ids)
icc_data_complete <- merge(S3_icc_means, S1_icc_means, by = "token")
```

### Time between measurements
```{r, include=T, echo = F}
icc_data_complete$t1_date <- as.Date(icc_data_complete$ts.x, "CET") #extract the date from t1 

icc_data_complete$ts.y <- as.POSIXct(icc_data_complete$ts.y) #transform character format of t2 to POSIXct 
icc_data_complete$t2_date <- as.Date(icc_data_complete$ts.y, "CET") #extract the date from t2 

time_between <- abs(icc_data_complete$t2_date - icc_data_complete$t1_date) #compute the difference between t2 and t1
time_between <- as.numeric(time_between)
```

```{r, include=T}
mean(time_between) #mean time was 216.1903 days or ~7.206343 months or 30.88433 weeks
min(time_between) #minimum time was 194 days or 27.71429 weeks
max(time_between) #maximum time was 254 days or 36.28571 weeks
```

```{r, include=F}
#append time_between to the dataframe that I will use for the analysis
icc_data_complete <- cbind(icc_data_complete, time_between)
```

### Mixed effects modelling to estimate repeatability {.tabset}
Based on the previous steps, we know that the data is not normally distributed so we will use the mixed effects model from the rptR package to inspect the repeatability of the ICE scores for each emotion. Using this framework, we will follow the logic of the intra-class correlation coefficient and set a 2-way mixed effects model with k = 2 mean rating and absolute agreement (Koo and Li, 2016). In order to evaluate the uncertainty in the repeatability estimate, let's run 999 permutations for each model.

#### climate anger
```{r, include=F}
#reorganise the data

#anger
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.anger, icc_data_complete$t2_Mclimate.anger, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")

icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)

icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE}
#run dry tests first
#rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), nboot = 0, npermut = 0)

#adjust for time in between
#rpt(value~token+time_between+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), nboot = 0, npermut = 0)
### I get a warning: fixed-effect model matrix is rank deficient so dropping 1 column / coefficient
# This is likely because 'time_between" is reduntant in this model. I leave it out.

###Since the dry run worked fine and we see sizable repeatability, in order to evaluate the uncertainty in the repeatability estimate, and since the data is not normally distributed, I run it with 999 permutations
rpt(value~token+(1|measure.point), grname = "measure.point", 
    data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate contempt

```{r, include=F}
#### climate contempt
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.contempt, icc_data_complete$t2_Mclimate.contempt, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE,  echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", 
    data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate enthusiasm

```{r, include=F}
#### climate enthusiasm
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.enthusiasm, icc_data_complete$t2_Mclimate.enthusiasm, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate powerlessness
```{r, include=F}
##climate powerlessness
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.powerlessness, icc_data_complete$t2_Mclimate.powerlessness, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate guilt

```{r, include=F}
##climate guilt
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.guilt, icc_data_complete$t2_Mclimate.guilt, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate isolation
```{r, include=F}
##climate isolation
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.isolation, icc_data_complete$t2_Mclimate.isolation, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate anxiety
```{r, include=F}
##climate anxiety
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.anxiety, icc_data_complete$t2_Mclimate.anxiety, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```

#### climate sorrow
```{r, include=F}
##climate sorrow
#reorganise the data
icc_perm <- cbind.data.frame(icc_data_complete$t1_Mclimate.sorrow, icc_data_complete$t2_Mclimate.sorrow, icc_data_complete$token, icc_data_complete$time_between)
colnames(icc_perm) <- c("measure1", "measure2", "token", "time_between")
icc_perm <- gather(
  icc_perm, key=measure.point, value=value, measure1, measure2)
icc_perm$token <- as.factor(icc_perm$token)
icc_perm$measure.point <- as.factor(icc_perm$measure.point)
```

``` {r, message = FALSE, echo=FALSE}
rpt(value~token+(1|measure.point), grname = "measure.point", data = icc_perm, adjusted = T, datatype = c("Gaussian"), 
    nboot = 0, npermut = 999)
```


## Climate emotions & mental health   

```{r, include=F}
#Create one df with the relevant variables for this step of the analysis
cor_df2 <- cbind(s_ICE_32, s_MHC)
```

```{r, include=F}
#age <- 2022 - as.numeric(qdata$`demo-0-pl.3`)
#gender <- as.numeric(qdata$`demo-0-pl.1`)
#cc_concern <- as.numeric(qdata$`demo-0-pl.0`) + 1
#education <- as.numeric(qdata$`demo-0-pl.8`)
#political_views <- as.numeric(qdata$`demo-0-pl.12`)
#239 - sum(is.na(political_views))  #only 124 people said they can indicate their views of the scale from left to right or that they had any political views at all
#perceived_SES <- 5 - as.numeric(qdata$`demo-0-pl.13`)   #it was 'reverse scored' - Which of the descriptions below comes closest to how you     feel about your household’s income nowadays?"      :opt ("Living comfortably on present income"            "Coping on present income"            "Finding it difficult on present income"            "Finding it very difficult on present income")

#cor_df2 <- cbind(cor_df2, age, gender, cc_concern, education, political_views, perceived_SES)
```
### Correlation table
Let's use the Spearman correlation coefficient because the data is ordinal and non-parametrically distributed

```{r, include=T, message = FALSE, echo=F}
#For the correlations, I use the custom correlation_matrix and save_correlation_matrix functions from Paul van der Laken, the code can be found here and it is included in the beginning of this script: https://paulvanderlaken.com/2020/07/28/publication-ready-correlation-matrix-significance-r/#correlation_matrix

knitr::kable(correlation_matrix(cor_df2, type = "spearman", digits = 2, use = 'lower', replace_diagonal = T), "simple")
```
```{r, include=F}
#save it in a format that can be readily copied to the paper
#save_correlation_matrix(cor_df2, filename = "health_cor.csv", type = "spearman", digits = 2, use = 'lower', replace_diagonal = T)
```

## Note

This HTML output presents the general logic of the analysis along with some results not outlined in the main body of the manuscript. Please note that the full R code for the data cleaning and data analysis is available in the supplementary materials on the accompanying OSF website.
